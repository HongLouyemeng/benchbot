#!/usr/bin/env bash

################################################################################
################### Load Helpers & Global BenchBot Settings ####################
################################################################################

set -euo pipefail
IFS=$'\n\t'
abs_path=$(readlink -f $0)
pushd $(dirname $abs_path) > /dev/null
source .helpers

################################################################################
########################### Script Specific Settings ###########################
################################################################################

# empty

################################################################################
######################## Helper functions for commands #########################
################################################################################

usage_text="$(basename "$abs_path") -- Run script for the BenchBot backend & simulator / real robot

USAGE:

    Get info about the program / available options:
        $(basename "$abs_path") [-h|--help|--list-tasks|--list-envs]

    Run a simulator with a specific task setup:
        $(basename "$abs_path") --env ENV_NAME --task TASK_NAME
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME

    Request the backend to explicitly use the carter robot platform:
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME --robot carter

OPTION DETAILS:

    -h,--help             
            Show this help menu.

    -e, --env, --environment
            Select an environment to launch in the simulator (this must be
            called with the --task option). Environments are identified via
            \"ENVIRONMENT_NAME:VARIATION_NUMBER\" where ENVIRONMENT_NAME is the
            name of simulated environment & VARIATION_NUMBER environment
            variation to use. For example, the third variation of the office
            environment would be: 

                    office:3

            Some tasks may require more than one environment variation (e.g.
            scene change detection). Multiple variations are specified using
            the format \"ENVIRONMENT_NAME:VARIATION_ONE:VARIATION_TWO\".  For
            example using the first, and then third variation of the office
            environment would be specified via:

                    office:1:3

            (Use --list-envs to see a list of available environments)

    -f, --force-updateless
            BenchBot will exit if it detects updates to the software stack. Set
            this flag to continue using outdated software temporarily. Note that
            limited support is available for outdated software stacks, and all
            novel work will focus on the latest software stack. You should only
            use this flag when it is inconvenient to update immediately.

    --list-envs, --list-environments
            Search for & list all installed environments. The listed
            environment names are in the format needed for the --env option.

    --list-robots
            List all supported robot targets. This list will adjust to include
            what is available in your current installation (i.e. there will be
            no simulated robots listed if you installed with '--no-simulator')

    --list-tasks   
            Lists all supported task combinations. The listed tasks are printed
            in the format needed for the --task option.

    -r, --robot
            Configure the BenchBot supervisor for a specific robot. This
            currently is used to select either a simulator or real robot, but
            has all the flexibility in the future to target any desired robot
            platform, whether that be simulated or real.

            If the full backend is installed (with a simulator), the 'sim'
            target robot will be used by default, otherwise the 'real' target
            robot will be the default.

            (Use --list-robots to see a list of available robots)

    -t, --task             
            Configure BenchBot for a specific task style (this must be called
            with the --env option). Tasks are specified based on their name in
            the YAML file. The naming convention generally follows the format
            \"TYPE:OPTION_1:OPTION_2:...\". For example:

                    semantic_slam:passive:ground_truth\"

            is a semantic SLAM task with passive robot control and observations
            using a ground truth robot pose. 

            (Use --list-tasks to see a list of supported task options)

    -u,--update-check
            Check for available updates to the BenchBot software stack and exit
            immediately.

    -v,--version
            Print version info for current installation.

FURTHER DETAILS:
    
    Please contact the authors of BenchBot for support or to report bugs:
        b.talbot@qut.edu.au
    "

_robot_err=\
"ERROR: The BenchBot Robot Controller container has exited unexpectedly. This 
should not happen unless something is installed incorrectly. Please see the
complete log below for a dump of the crash output:"

function exit_gracefully() {
  if [ -z "$simulator_required" ]; then
    printf "\n\n${colour_blue}%s${colour_nc}\n" \
      "Re-closing network openings used for real robot:"
    close_network $network_forwarding $network_policy
  fi
  kill_benchbot
  exit ${1:-0}
}

function opt_list_envs() {
  # TODO check if installed (docker image exists); provide a message if not
  # telling them how to fix the issue
  # Print the list with details
  l="$(run_manager_cmd '[print("\t%s" % e) for e in \
    sorted(get_field("environments", "name"))]')"
  echo "Either simulated or real world environments can be selected. Please see the
'--list-robots' command for the available robot platforms. Only simulated robots 
can be run in simulated environments, and only real robots in real environments 
(as you would expect).

The following environments are supported in your BenchBot installation:
    "
  if [ -z "$l" ]; then echo -e "\tNONE!"; else echo "$l"; fi
  echo "
See the '--show-environment ENVIRONMENT_NAME' command for specific details about
each environment, or check you have the appropriate add-on installed if you are
missing an environment.
"
}

function opt_list_robots() {
  # TODO this will need to be redone in a more flexible way to support a more
  # dynamic style of "robot" target creation
  l="$(run_manager_cmd '[print("\t%s" % r) for r in \
    sorted(get_field("robots", "name"))]')"
  echo "The following robot targets are supported in your BenchBot installation:
        "
  if [ -z "$l" ]; then echo -e "\tNONE!"; else echo "$l"; fi
  echo "
See the '--show-robot ROBOT_NAME' command for specific details about each robot,
or check you have the appropriate add-on installed if you are missing a robot.
"
}

function opt_list_tasks() {
  # TODO this is hard coded for now... maybe should be done differently...
  l="$(run_manager_cmd '[print("\t%s" % t) for t in \
    sorted(get_field("tasks", "name"))]')"
  echo "The following tasks are supported in your BenchBot installation: 
  "
  if [ -z "$l" ]; then echo -e "\tNONE!"; else echo "$l"; fi
  echo "
See the '--show-task TASK_NAME' command for specific details about each task, or
check you have the appropriate add-on installed if you are missing a task.
"
}

function _show_content() {
  singular=${1::-1}
  if [ "$(run_manager_cmd 'print(exists("'$1'", "name", "'$2'"))')" \
      != "True" ]; then
    printf "%s %s\n" "${singular^} '$2' is not a supported ${singular}." \
      "Please check '--list-$1'."
    exit 1
  fi
  location=$(run_manager_cmd 'print(get_match("'$1'", "name", "'$2'"))')
  printf "${singular^} '$2' was found at the following location:\n\n\t%s\n\n" \
    "$location"
  printf "Printed below are the first 30 lines of the definition file:\n\n"
  head -n 30 "$location"
  printf "\n"
}

function opt_show_env() {
  _show_content "environments" "$1"
}

function opt_show_robot() {
  _show_content "robots" "$1"
}

function opt_show_task() {
  _show_content "tasks" "$1"
}

function validate_environment_count() {
  # $1 = number of selected environments, $2 task
  scene_count="$(run_manager_cmd 'print(\
    get_value_by_name("tasks", "'$2'", "scene_count"))')"
  if [[ "$scene_count" == *"None"* ]]; then scene_count=1; fi
  if [ $scene_count -ne $1 ]; then
    printf "\n${colour_red}%s\n       %s${colour_nc}\n" \
      "ERROR: Selected '$1' environments for a task which requires '$scene_count'" \
      "environments ('$task')"
  fi
}

function validate_content() {
  # $1 = content type; $2 = name; $3 = full name (optional)
  singular=${1::-1}
  full=$([ -z "${3-}" ] && echo "$2" || echo "$3")
  if [ "$(run_manager_cmd 'print(exists("'$1'", "name", "'$2'"))')" \
      != "True" ]; then
    printf "%s %s\n" "${singular^} '$2' is not a supported ${singular}." \
      "Please check '--list-$1'."
    printf "\n${colour_red}%s${colour_nc}\n" \
      "ERROR: Invalid ${singular} selected (${singular} = '$full')"
  fi
}

function validate_type() {
  # $1 = type
  if [ "$1" == "real" ]; then
    printf "\n${colour_yellow}%s\n%s${colour_nc}\n" \
      "WARNING: Requested running with '$1'. Assuming you have an available" \
      "real robot & environment."
    return
  fi

  simulators="$(simulator_type)"
  if [ "$simulators" != "$1" ] && [ "$simulators" != *",$1" ] && \
      [ "$simulators" != *"$1,"* ]; then
    printf "\n${colour_red}%s\n       %s${colour_nc}\n" \
      "ERROR: Requested running with '$1', but that simulator isn't installed." \
      "Installed simulator/s are: '$simulators'"
  fi
}

function validate_types() {
  # $1 = robot name; $2 = environment string, $3... environments
  robot="$1"
  env="$2" 
  shift 2
  envs=($@)
  types=()
  types+=("$(run_manager_cmd 'print(\
    get_value_by_name("robots", "'$robot'", "type"))')")
  for e in "${envs[@]}"; do
    types+=($(run_manager_cmd 'print(\
      get_value_by_name("environments", "'$e'", "type"))'))
  done

  err=
  for i in "${!types[@]}"; do
    if [ "${types[$i]}" != "${types[0]}" ]; then err=1; fi
  done

  if [ ! -z "$err" ]; then
    printf "%s %s\n%s\n\n" "Robot & environment types aren't consistent." \
      "Please ensure each of the following" "have the same type:"
    for i in "${!types[@]}"; do
      if [ $i -eq 0 ]; then
        printf "\tRobot '$robot' has type '${types[$i]}'\n"
      else
        printf "\tEnvironment '${envs[$((i-1))]}' has type '${types[$i]}'\n"
      fi
    done
    printf "\n${colour_red}%s${colour_nc}\n" \
      "ERROR: Inconsistent types selected (robot = '$1', environment = '$3')"
  fi
}


################################################################################
#################### Parse & handle command line arguments #####################
################################################################################

# Safely parse options input
_args="help,env:,environment:,force-updateless,list-envs,list-environments,\
list-robots,list-tasks,robot:,show-env:,show-environment:,show-robot:,\
show-task:,task:,updates-check,version"
parse_out=$(getopt -o he:t:r:fuv --long $_args  -n "$(basename "$abs_path")" \
  -- "$@")
if [ $? != 0 ]; then exit 1; fi
eval set -- "$parse_out"
updates_exit=
updates_skip=
environment=
robot=
task=
while true; do
  case "$1" in
    -h|--help)
      echo "$usage_text" ; exit 0 ;;
    -e|--env|--environment)
      environment="$2"; shift 2 ;;
    -f|--force-updateless)
      updates_skip=1 ; shift ;;
    --list-envs|--list-environments)
      opt_list_envs ; exit $? ;;
    --list-robots)
      opt_list_robots ; exit $? ;;
    --list-tasks)
      opt_list_tasks ; exit $? ;;
    -r|--robot)
      robot="$2"; shift 2 ;;
    --show-env|--show-environment)
      opt_show_env "$2" ; exit $? ;;
    --show-robot)
      opt_show_robot "$2"; exit $? ;;
    --show-task)
      opt_show_task "$2"; exit $? ;;
    -t|--task)
      task="$2"; shift 2 ;;
    -u|--updates-check)
      updates_exit=1 ; shift ;;
    -v|--version)
      print_version_info; exit ;;
    --)
      shift ; break ;;
    *)
      echo "$(basename "$abs_path"): option '$1' is unknown"; shift ; exit 1 ;;
  esac
done

# Extract a list of environments from the provided environment string
_pre="$(echo "$environment" | sed 's/:.*//')"
environments=($(echo "$environment" | sed 's/[^:]*\(:.*\)/\1/; s/:/\n'$_pre':/g; s/^ *//'))
if [ ${#environments[@]} -eq 0 ]; then environments+=(""); fi
environments_string="$(printf '%s\n' "${environments[@]}")"

# Determine type of run being performed
type="$(run_manager_cmd 'print(\
  get_value_by_name("robots", "'$robot'", "type"))')"
simulator_required=1; if [[ "$type" != "sim_"* ]]; then simulator_required=0; fi

# Bail if any of the requested configurations are invalid
if [ -z "$updates_exit" ]; then
  # Process environment, task, & robot selections
  for e in "${environments[@]}"; do
    err="$(validate_content "environments" "$e" "$environment")"
    if [ ! -z "$err" ]; then echo "$err"; exit 1; fi
  done
  err="$(validate_content "robots" "$robot")"
  if [ ! -z "$err" ]; then echo "$err"; exit 1; fi
  err="$(validate_content "tasks" "$task")"
  if [ ! -z "$err" ]; then echo "$err"; exit 1; fi
  err="$(validate_types "$robot" "$environment" "${environments[@]}")"
  if [ ! -z "$err" ]; then echo "$err"; exit 1; fi
  err="$(validate_type "$type")"; echo "$err"
  if [[ "$err" == *"ERROR:"* ]]; then exit 1; fi
  err="$(validate_environment_count ${#environments[@]} "$task")"
  if [ ! -z "$err" ]; then echo "$err"; exit 1; fi
fi

################################################################################
############## Run the simulator / real robot & BenchBot backend ###############
################################################################################

# Check for & handles updates to the BenchBot software stack
header_block "CHECKING FOR BENCHBOT SOFTWARE STACK UPDATES" ${colour_blue}

if [ ! -z "$updates_skip" ]; then 
  echo -e "${colour_yellow}Skipping ...${colour_nc}"
elif ! update_check "$(git branch -a --contains HEAD | grep -v HEAD | \
    grep '.*remotes/.*' | head -n 1 | sed 's/.*\/\(.*\)/\1/')"; then 
  exit 1; 
fi
if [ ! -z "$updates_exit" ]; then exit 0; fi

# Run the BenchBot software stack (kill whenever they exit)
trap exit_gracefully SIGINT SIGQUIT SIGKILL SIGTERM
header_block "STARTING THE BENCHBOT SOFTWARE STACK" ${colour_blue}

# Print some configuration information
printf "${colour_blue}%s${colour_nc}

    Selected task:        $task
    Selected robot:       $robot
    Selected environment: $environment
    Scene/s:              " \
      "Running the BenchBot system with the following settings:"
for i in "${!environments[@]}"; do
  if [ $i -ne 0 ]; then
    printf "%*s" 26
  fi
  printf "%s, starting @ pose %s\n" "${environments[$i]}" \
    "$(run_manager_cmd 'print(get_value_by_name("environments", \
      "'${environments[$i]}'", "start_pose"))')"
  printf "%*s" 26
  printf "(map_path = '%s')\n" \
    "$(run_manager_cmd 'print(get_value_by_name("environments", \
    "'${environments[$i]}'", "map_path"))')"
done
printf "    %-22s" "Simulator required:"
printf "%s (%s)\n"  $([ -z "$simulator_required" ] && echo "No" || echo "Yes") \
  "$type"
echo ""

# Create the network for BenchBot software stack
echo -e "${colour_blue}Creating shared network '$DOCKER_NETWORK':${colour_nc}"
docker network create "$DOCKER_NETWORK" --subnet="$URL_DOCKER_SUBNET" \
  --ip-range="$URL_DOCKER_SUBNET" --gateway="$URL_DOCKER_GATEWAY"
if [ -z "$simulator_required" ]; then
  printf "\n${colour_blue}%s${colour_nc}\n" \
    "Opening network to facilitate communications with real robot:"
  network_forwarding=$(cat /proc/sys/net/ipv4/conf/all/forwarding)
  network_policy=$(sudo iptables --list FORWARD | head -n 1 | \
    sed 's/Chain.*(policy \([^)]*\))/\1/')
  open_network;
fi

# Declare reusable parts to ensure our containers run with consistent settings
xhost +local:root > /dev/null
ros_master_host="benchbot_roscore"
docker_run="docker run -t --gpus all \
            --env DISPLAY \
            --env ROS_MASTER_URI=http://$ros_master_host:11311 \
            --env ROS_HOSTNAME=\$name \
            --network $DOCKER_NETWORK \
            --name=\$name \
            --hostname=\$name \
            --volume /tmp/.X11-unix:/tmp/.X11-unix \
            --volume $PATH_ADDONS:$PATH_ADDONS_INTERNAL:ro"
cmd_prefix='source $ROS_WS_PATH/devel/setup.bash && '

# Start containers for ROS, isaac_simulator, benchbot_simulator, & benchbot_supervisor
echo -e "\n${colour_blue}Starting container for BenchBot ROS:${colour_nc}"
cmd="${docker_run//'$name'/$ros_master_host}"
${cmd// /$'\t'} --ip "$URL_ROS" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'roscore'

if [ ! -z "$simulator_required" ]; then
  printf "\n${colour_blue}%s${colour_nc}\n" \
    "Starting container for BenchBot Robot Controller:"
  cmd="${docker_run//'$name'/benchbot_robot}"
  ${cmd// /$'\t'} --ip "$URL_ROBOT" -d $DOCKER_TAG_BACKEND /bin/bash -c \
    "$cmd_prefix"'rosrun benchbot_robot_controller benchbot_robot_controller'
fi

echo -e "\n${colour_blue}Starting container for BenchBot Supervisor:${colour_nc}"
cmd="${docker_run//'$name'/benchbot_supervisor}"
${cmd// /$'\t'} --ip "$URL_SUPERVISOR" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'pushd $BENCHBOT_ADDONS_PATH && \
  task_file=$(./call_manager '"'"'print(get_match("tasks", "name", \
  "'"$task"'"))'"'"') &&
  robot_file=$(./call_manager '"'"'print(get_match("robots", "name", \
  "'"$robot"'"))'"'"') &&
  env_files=$(./call_manager '"'"'print(":".join(\
    [get_match("environments", "name", e) for e in \
     "'"${environments_string//$'\n'/;}"'".split(";")]))'"'"') &&
  python -m benchbot_supervisor --task-file "$task_file" \
  --robot-file "$robot_file" --environment-files "$env_files"'

echo -e "\n${colour_blue}Starting container for BenchBot Debugging:${colour_nc}"
cmd="${docker_run//'$name'/benchbot_debug}"
${cmd// /$'\t'} --ip "$URL_DEBUG" -it -d $DOCKER_TAG_BACKEND /bin/bash
xhost -local:root > /dev/null

# Print the output of the Supervisor, watching for failures
header_block "BENCHBOT IS RUNNING (Ctrl^C to exit) ..." ${colour_green}

docker logs benchbot_supervisor
docker attach benchbot_supervisor --no-stdin &

while [ ! -z $(docker ps -q -f 'name=benchbot_supervisor') ] && \
  ([ -z "$simulator_required" ] || \
  [ ! -z $(docker ps -q -f 'name=benchbot_robot') ]); do
  sleep 1
done

if [ ! -z "$simulator_required" ] && \
    [ -z $(docker ps -q -f 'name=benchbot_robot') ]; then
  header_block "BENCHBOT ROBOT CONTROLLER ERROR" ${colour_red}
  echo -e "\n${colour_red}$_robot_err${colour_nc}\n"
  docker logs benchbot_robot
fi
exit_gracefully 1
