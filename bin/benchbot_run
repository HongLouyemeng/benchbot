#!/usr/bin/env bash

################################################################################
################### Load Helpers & Global BenchBot Settings ####################
################################################################################

abs_path=$(readlink -f $0)
pushd $(dirname $abs_path) > /dev/null
source .helpers

################################################################################
########################### Script Specific Settings ###########################
################################################################################

# empty

################################################################################
######################## Helper functions for commands #########################
################################################################################

usage_text="$(basename "$abs_path") -- Run script for the BenchBot backend & simulator / real robot

USAGE:

    Get info about the program / available options:
        $(basename "$abs_path") [-h|--help|--list-tasks|--list-envs]

    Run a simulator with a specific task setup:
        $(basename "$abs_path") --env ENV_NAME --task TASK_NAME
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME

    Request the backend to explicitly use the carter robot platform:
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME --robot carter

OPTION DETAILS:

    -h,--help             
            Show this help menu.

    -e, --env             
            Select an environment to launch in the simulator (this must be
            called with the --task option). Environments are identified via
            \"ENVIRONMENT_NAME:VARIATION_NUMBER\" where ENVIRONMENT_NAME is the
            name of simulated environment & VARIATION_NUMBER environment
            variation to use. For example, the third variation of the office
            environment would be: 

                    office:3

            Some tasks may require more than one environment variation (e.g.
            scene change detection). Multiple variations are specified using
            the format \"ENVIRONMENT_NAME:VARIATION_ONE:VARIATION_TWO\".  For
            example using the first, and then third variation of the office
            environment would be specified via:

                    office:1:3

            (Use --list-envs to see a list of available environments)

    -f, --force-updateless
            BenchBot will exit if it detects updates to the software stack. Set
            this flag to continue using outdated software temporarily. Note that
            limited support is available for outdated software stacks, and all
            novel work will focus on the latest software stack. You should only
            use this flag when it is inconvenient to update immediately.

    --list-envs
            Search for & list all installed environments. The listed
            environment names are in the format needed for the --env option.

    --list-robots
            List all supported robot targets. This list will adjust to include
            what is available in your current installation (i.e. there will be
            no simulated robots listed if you installed with '--no-simulator')

    --list-tasks   
            Lists all supported task combinations. The listed tasks are printed
            in the format needed for the --task option.

    -r, --robot
            Configure the BenchBot supervisor for a specific robot. This
            currently is used to select either a simulator or real robot, but
            has all the flexibility in the future to target any desired robot
            platform, whether that be simulated or real.

            If the full backend is installed (with a simulator), the 'sim'
            target robot will be used by default, otherwise the 'real' target
            robot will be the default.

            (Use --list-robots to see a list of available robots)

    -t, --task             
            Configure BenchBot for a specific task style (this must be called
            with the --env option). Tasks are specified based on their name in
            the YAML file. The naming convention generally follows the format
            \"TYPE:OPTION_1:OPTION_2:...\". For example:

                    semantic_slam:passive:ground_truth\"

            is a semantic SLAM task with passive robot control and observations
            using a ground truth robot pose. 

            (Use --list-tasks to see a list of supported task options)

    -u,--update-check
            Check for available updates to the BenchBot software stack and exit
            immediately.

    -v,--version
            Print version info for current installation.

FURTHER DETAILS:
    
    Please contact the authors of BenchBot for support or to report bugs:
        b.talbot@qut.edu.au
    "

_robot_err=\
"ERROR: The BenchBot Robot Controller container has exited unexpectedly. This 
should not happen unless something is installed incorrectly. Please see the
complete log below for a dump of the crash output:"

SELECTED_ENV=
SELECTED_TASK=

function exit_gracefully() {
  if [ -z "$simulator_required" ]; then
    printf "\n\n${colour_blue}%s${colour_nc}\n" \
      "Re-closing network openings used for real robot:"
    close_network $network_forwarding $network_policy
  fi
  kill_benchbot
  exit ${1:-0}
}

function opt_list_envs() {
  # TODO check if installed (docker image exists); provide a message if not
  # telling them how to fix the issue
  # Print the list with details
  echo "$_env_data_full_cached"
  echo "Either simulated or real world environments can be selected. Please see the
'--list-robots' command for the available simulated and real robot platforms.
Only simulated robots can be run in simulated environments, and only real
robots in real environments (as you would expect).

Support for the following environments is provided in your installed BenchBot
Docker image:

    Simulated: 

    Real word: 
    "
}

function opt_list_robots() {
  # TODO this will need to be redone in a more flexible way to support a more
  # dynamic style of "robot" target creation
  echo "The following robot targets are supported in your BenchBot installation:
        "
  echo -e "\nPlease ensure you run a robot in a valid environment (i.e. running a real 
robot platform in a simulated environment is an invalid configuration)."
}

function opt_list_tasks() {
  # TODO this is hard coded for now... maybe should be done differently...
  echo "The following tasks are supported by BenchBot: 
  "
  echo "
See the '--show-task TASK_NAME' command for specific details about each task.
"
}

function opt_select_env() {
  # Only update the SELECTED_ENV variable if it is in the list of envs
  # TODO redo validation tests
  echo "Environment '$1' is not a supported environment. Please check --list-envs."
  return 1
}

function opt_select_robot() {
  # Only update the SELECTED_ROBOT variable if it is in the list of robots
  # TODO redo validation tests (note: carter fallback default)
  echo "Robot '$1' is not a supported robot platform. Please check --list-robots."
  return 1
}

function opt_select_task() {
  # Only update the SELECTED_TASK variable if it is in the list of tasks
  # TODO redo validation tests
  echo "Task '$1' is not a supported task specification. Please check --list-tasks."
  return 1
}


################################################################################
#################### Parse & handle command line arguments #####################
################################################################################

# Safely parse options input
parse_out=$(getopt -o he:t:r:fuv \
  --long help,env:,force-updateless,list-envs,list-robots,list-tasks,robot:,task:,updates-check,version \
  -n "$(basename "$abs_path")" -- "$@")
if [ $? != 0 ]; then exit 1; fi
eval set -- "$parse_out"
updates_exit=
updates_skip=
robot_selection=
while true; do
  case "$1" in
    -h|--help)
      echo "$usage_text" ; exit 0 ;;
    -e|--env)
      _env_data_get ; opt_select_env "$2"; shift 2 ;;
    -f|--force-updateless)
      updates_skip=1 ; shift ;;
    --list-envs)
      _env_data_get ; opt_list_envs ; exit 0 ;;
    --list-robots)
      _robot_data_get; opt_list_robots ; exit 0 ;;
    --list-tasks)
      opt_list_tasks ; exit 0 ;;
    -r|--robot)
      robot_selection="$2"; shift 2 ;;
    -t|--task)
      opt_select_task "$2"; shift 2 ;;
    -u|--updates-check)
      updates_exit=1 ; shift ;;
    -v|--version)
      print_version_info; exit ;;
    --)
      shift ; break ;;
    *)
      echo "$(basename "$abs_path"): option '$1' is unknown"; shift ; exit 1 ;;
  esac
done
_robot_data_get; opt_select_robot "$robot_selection"

# Bail if we are running & we didn't get a valid robot, env, & task
if [ -z "$updates_exit" ]; then
  if [ -z "$SELECTED_ROBOT" ]; then
    printf "${colour_red}%s${colour_nc}\n" \
      "ERROR: No valid robot selected (selected_robot = "$SELECTED_ROBOT")"
    exit 1
  fi
  if [ -z "$SELECTED_ENV" ]; then 
    printf "${colour_red}%s${colour_nc}\n" \
      "ERROR: No valid environment selected (selected_env = "$SELECTED_ENV")"
    exit 1
  fi
  if [ -z "$SELECTED_TASK" ]; then 
    printf "${colour_red}%s${colour_nc}\n" \
      "ERROR: No valid task selected (selected_task = "$SELECTED_TASK")"
    exit 1
  fi
  if [ -z "$(simulator_type)" ] && \
      [[ "$(_robot_type "$SELECTED_ROBOT")" == *"sim"* ]]; then
    printf "${colour_red}%s\n%s${colour_nc}\n" \
      "ERROR: Can't run a simulated robot (selected_robot = "$SELECTED_ROBOT") in an" \
      "installation that doesn't have a simulator installed."
    exit 1
  fi
  if [[ "$(_robot_type "$SELECTED_ROBOT")" \
      != *"$(_env_type "$SELECTED_ENV")"* ]]; then
    printf "${colour_red}%s\n%s${colour_nc}\n" \
      "ERROR: Type mismatch between selected robot & environment" \
      "(selected_robot = "$SELECTED_ROBOT", selected_env= "$SELECTED_ENV")"
    exit 1
  fi
fi

# Ensure task & environment combo is valid
# TODO ensure the number of selected variations matches the number selected in
# the task

################################################################################
############## Run the simulator / real robot & BenchBot backend ###############
################################################################################

# Check for & handles updates to the BenchBot software stack
header_block "CHECKING FOR BENCHBOT SOFTWARE STACK UPDATES" ${colour_blue}

if [ ! -z "$updates_skip" ]; then 
  echo -e "${colour_yellow}Skipping ...${colour_nc}"
elif ! update_check "$(git branch -a --contains HEAD | grep -v HEAD | grep '.*remotes/.*' | head -n 1 | sed 's/.*\/\(.*\)/\1/')"; then 
  exit 1; 
fi
if [ ! -z "$updates_exit" ]; then exit 0; fi

# Run the BenchBot software stack (kill whenever they exit)
trap exit_gracefully SIGINT SIGQUIT SIGKILL SIGTERM
header_block "STARTING THE BENCHBOT SOFTWARE STACK" ${colour_blue}

# Pull out all useful data from the selected settings
# TODO do this through add-on manager

if [ ! -z "$(simulator_type)" ] && \
    [[ "$(_robot_type "$SELECTED_ROBOT")" == *"sim"* ]]; then
  simulator_required=1
fi

# Print some configuration information
echo -n -e "${colour_blue}Running the BenchBot system with the following settings:${colour_nc}

    Selected environment: $SELECTED_ENV
    Selected task:        $SELECTED_TASK
    Selected robot:       $SELECTED_ROBOT
    Maps:                 "
for i in "${!selected_map_paths[@]}"; do
  if [ $i -ne 0 ]; then
    printf "%*s" 26
  fi
  printf "%s\n" "${selected_map_paths[$i]}"
  printf "%*s" 26
  printf "(starting @ %s)\n" "${selected_poses[$i]}"
done
printf "    %-22s" "Simulator required:"
printf "%s\n"  $([ -z "$simulator_required" ] && echo "No" || echo "Yes")
echo ""

# Create the network for BenchBot software stack
echo -e "${colour_blue}Creating shared network '$DOCKER_NETWORK':${colour_nc}"
docker network create "$DOCKER_NETWORK" --subnet="$URL_DOCKER_SUBNET" \
  --ip-range="$URL_DOCKER_SUBNET" --gateway="$URL_DOCKER_GATEWAY"
if [ -z "$simulator_required" ]; then
  printf "\n${colour_blue}%s${colour_nc}\n" \
    "Opening network to facilitate communications with real robot:"
  network_forwarding=$(cat /proc/sys/net/ipv4/conf/all/forwarding)
  network_policy=$(sudo iptables --list FORWARD | head -n 1 | \
    sed 's/Chain.*(policy \([^)]*\))/\1/')
  open_network;
fi

# Declare reusable parts to ensure our containers run with consistent settings
xhost +local:root > /dev/null
ros_master_host="benchbot_roscore"
docker_run="docker run -t --gpus all -v /tmp/.X11-unix:/tmp/.X11-unix \
            -e DISPLAY \
            -e ROS_MASTER_URI=http://$ros_master_host:11311 -e ROS_HOSTNAME=\$name \
            --network $DOCKER_NETWORK --name=\$name --hostname=\$name \
            --volume $PATH_ADDONS:/addons:ro"
cmd_prefix='source $ROS_WS_PATH/devel/setup.bash && '

# Start containers for ROS, isaac_simulator, benchbot_simulator, & benchbot_supervisor
echo -e "\n${colour_blue}Starting container for BenchBot ROS:${colour_nc}"
name="$ros_master_host"
${docker_run//'$name'/$name} --ip "$URL_ROS" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'roscore'

if [ ! -z "$simulator_required" ]; then
  printf "\n${colour_blue}%s${colour_nc}\n" \
    "Starting container for BenchBot Robot Controller:"
  name="benchbot_robot"
  ${docker_run//'$name'/$name} --ip "$URL_ROBOT" -d $DOCKER_TAG_BACKEND /bin/bash -c \
    "$cmd_prefix"'rosrun benchbot_robot_controller benchbot_robot_controller'
fi

echo -e "\n${colour_blue}Starting container for BenchBot Supervisor:${colour_nc}"
name="benchbot_supervisor"
${docker_run//'$name'/$name} --ip "$URL_SUPERVISOR" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'python -m benchbot_supervisor \
  --task-file "'"$SELECTED_TASK"'" --robot-file "'"${SELECTED_ROBOT/:/_}"'.yaml" \
  --environment-files '"$( IFS=$':'; echo "${selected_env_files[*]}")"

echo -e "\n${colour_blue}Starting container for BenchBot Debugging:${colour_nc}"
name="benchbot_debug"
${docker_run//'$name'/$name} --ip "$URL_DEBUG" -it -d $DOCKER_TAG_BACKEND /bin/bash
xhost -local:root > /dev/null

# Print the output of the Supervisor, watching for failures
header_block "BENCHBOT IS RUNNING (Ctrl^C to exit) ..." ${colour_green}

docker logs benchbot_supervisor
docker attach benchbot_supervisor --no-stdin &

while [ ! -z $(docker ps -q -f 'name=benchbot_supervisor') ] && \
  ([ -z "$simulator_required" ] || \
  [ ! -z $(docker ps -q -f 'name=benchbot_robot') ]); do
  sleep 1
done

if [ ! -z "$simulator_required" ] && \
    [ -z $(docker ps -q -f 'name=benchbot_robot') ]; then
  header_block "BENCHBOT ROBOT CONTROLLER ERROR" ${colour_red}
  echo -e "\n${colour_red}$_robot_err${colour_nc}\n"
  docker logs benchbot_robot
fi
exit_gracefully 1
