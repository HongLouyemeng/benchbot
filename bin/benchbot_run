#!/usr/bin/env bash

################################################################################
################### Load Helpers & Global BenchBot Settings ####################
################################################################################

abs_path=$(readlink -f $0)
pushd $(dirname $abs_path) > /dev/null
source .helpers

################################################################################
########################### Script Specific Settings ###########################
################################################################################

# empty

################################################################################
######################## Helper functions for commands #########################
################################################################################

usage_text="$(basename "$abs_path") -- Run script for the BenchBot backend & simulator

USAGE:

    Get info about the program / available options:
        $(basename "$abs_path") [-h|--help|--list-tasks|--list-envs]

    Run a simulator with a specific task setup:
        $(basename "$abs_path") --env ENV_NAME --task TASK_NAME
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME

    Request the backend to explicitly use the carter robot platform:
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME --robot carter

OPTION DETAILS:

    -h,--help             
            Show this help menu.

    -e, --env             
            Select an environment to launch in the simulator (this must be
            called with the --task option). Environments are identified via
            \"ENVIRONMENT_NAME:VARIATION_NUMBER\" where ENVIRONMENT_NAME is the
            name of simulated environment & VARIATION_NUMBER environment
            variation to use. For example, the third variation of the office
            environment would be: 

                    office:3

            Two variation numbers must be specified for scene change detection
            using the format \"ENVIRONMENT_NAME:VARIATION_ONE:VARIATION_TWO\".
            For example detecting the changes in the third variation of the
            office with respect to the first variation would be:

                    office:1:3

            (Use --list-envs to see a list of available environments)

    -f, --force-updateless
            BenchBot will exit if it detects updates to the software stack. Set
            this flag to continue using outdated software temporarily. Note that
            limited support is available for outdated software stacks, and the
            challenge will run on the latest software stack. You should only use
            this flag when it is inconvenient to update immediately.

    --list-envs
            Search for & list all installed environments. The listed
            environment names are in the format needed for the --env option.

    --list-robots
            List all supported robot targets. This list will adjust to include
            what is available in your current installation (i.e. there will be
            no simulated robots listed if you installed with '--no-simulator')

    --list-tasks   
            Lists all supported task combinations. The listed tasks are printed
            in the format needed for the --task option.

    -r, --robot
            Configure the BenchBot supervisor for a specific robot. This
            currently is used to select either a simulator or real robot, but
            has all the flexibility in the future to target any desired robot
            platform, whether that be simulated or real.

            If the full backend is installed (with a simulator), the 'sim'
            target robot will be used by default, otherwise the 'real' target
            robot will be the default.

            (Use --list-robots to see a list of available robots)

    -t, --task             
            Configure BenchBot for a specific task style (this must be called
            with the --env option). A task is specified through the format
            \"TYPE:CONTROL_MODE:LOCALISATION_MODE\" where TYPE is the type of
            task, CONTROL_MODE is the control options available on the robot, &
            LOCALISATION_MODE is the accuracy of localisation feedback
            received. For example, a robot with passive control & ground truth
            localisation completing semantic SLAM would be:

                    semantic_slam:passive:ground_truth

            (Use --list-tasks to see a list of supported task options)

    -u,--update-check
            Check for available updates to the BenchBot software stack and exit
            immediately.

    -v,--version
            Print version info for current installation.

FURTHER DETAILS:
    
    Please contact the authors of BenchBot for support or to report bugs:
        b.talbot@qut.edu.au
    "

_map_details_err=\
"ERROR: Somehow there is a difference between the number of map paths (%d), map
poses (%d), & environment files (%d) found. This should never happen; please
contact the developers."

_simulator_err=\
"ERROR: The BenchBot Simulator container has exited unexpectedly. This should 
not happen unless something is installed incorrectly. Please see the complete
log below for a dump of the crash output:"

SELECTED_ENV=
SELECTED_TASK=

_task_list=("semantic_slam:passive:ground_truth"
  "semantic_slam:active:ground_truth"
  "semantic_slam:active:dead_reckoning"
  "scd:passive:ground_truth"
  "scd:active:ground_truth"
  "scd:active:dead_reckoning"
)

_env_data_full_cached=

function _env_files() {
  envs=($(_expand_envs $1))
  fs=
  for e in "${envs[@]}"; do
    fs+="$(_env_data $e | head -1 | tr -d '[:space:]') "
  done
  echo "$fs" | sed -e 's/[[:space:]]*$//'
}

function _env_data() {
  while read -r line; do
    if [ -z "$found" ] && [[ "$line" =~ ^/.*"${1/:/_}"\.yaml ]]; then
      found=true
      echo "$line"
    elif [ ! -z "$found" ] && [[ "$line" =~ ^/.*\.yaml ]]; then
      return 0
    elif [ ! -z "$found" ]; then
      echo "$line"
    fi
  done <<< "$_env_data_full_cached"
  return 1
}

function _env_data_get() {
  if [ -z "$(has_simulator)" ]; then
    _env_data_full_cached=""
  elif [ -z "$_env_data_full_cached" ]; then
    # A little hacky, but docker runs are costly so this gets everything in 1 go
    _env_data_full_cached=$(docker run --rm -t $DOCKER_TAG_BACKEND /bin/bash \
      -c 'find $BENCHBOT_ENVS_PATH/*/'$FILENAME_ENV_METADATA' -name "*.yaml"\
      | while read env; do echo "$(realpath $env)"; cat $env; echo ""; done')
  fi
}

function _env_list() {
  echo "$_env_data_full_cached" | grep "environment_name:" | \
    sed 's/.*: "\([^_]*\)_\([^"]*\).*/\1:\2/' | sort -u
}

function _env_map_paths() {
  envs=($(_expand_envs $1))
  ps=
  for e in "${envs[@]}"; do
    # Nested while... not quite ideal
    ps+="$(_env_data $e | sed -n 's/.*map_path: \(.*\)/\1/p' | \
      tr -d '[:space:]') "
  done
  echo "$ps" | sed -e 's/[[:space:]]*$//'
}

function _env_path() {
  envs=($(_expand_envs $1))
  echo "$_env_data_full_cached" | \
    grep -m 1 "^\/.*$(echo "${envs[${2:-0}]}" | tr ':' '_')" 
}

function _env_poses() {
  envs=($(_expand_envs $1))
  ps=
  for e in "${envs[@]}"; do
    # Nested while... not quite ideal
    ps+="$(_env_data $e | sed -n 's/.*start_pose_local: \(.*\)/\1/p' | \
      tr -d '[:space:]') "
  done
  echo "$ps" | sed -e 's/[[:space:]]*$//'
}

function _expand_envs() {
  env_name=$(echo "$1" | sed 's/:.*//')
  env_nums=($(echo "$1" | sed 's/[^:]*://; s/:/ /'))
  es=
  for e in "${env_nums[@]}"; do
    es+="$env_name:$e "
  done
  echo "$es" | sed -e 's/[[:space:]]*$//'
}

function exit_gracefully() {
  kill_benchbot
  exit ${1:-0}
}

function opt_list_envs() {
  # TODO check if installed (docker image exists); provide a message if not
  # telling them how to fix the issue
  # Print the list with details
  echo "A specific environment can be selected by entering a string in the format 
ENV_NAME:VARIATION_NUMBER. Scene change detection tasks require an environment 
string of the form ENV_NAME:VARIATION_NUMBER_1:VARIATION_NUMBER_2, as a second
variation is required in completing the task. 

Either simulated or real world environments can be selected. Please see the
'--list-robots' command for the available simulated and real robot platforms.
Only simulated robots can be run in simulated environments, and only real
robots in real environments (as you would expect).

Support for the following environments is provided in your installed BenchBot
Docker image:

    Simulated: 
        "
  if [ ! -z "$(has_simulator)" ]; then
    for e in $(_env_list); do
      echo "            $e"
    done
  else
    echo "             NONE (simulator not installed)"
  fi
  echo "

    Real word: 
             ???

  "
}

function opt_list_robots() {
  # TODO this will need to be redone in a more flexible way to support a more
  # dynamic style of "robot" target creation
  echo "The following robot targets are supported in your BenchBot installation:"
}

function opt_list_tasks() {
  # TODO this is hard coded for now... maybe should be done differently...
  echo "The following tasks are supported by BenchBot: 
  "
  for t in "${_task_list[@]}"; do
    echo "        $t"
  done
  echo "
The string is of the format TYPE:CONTROL_MODE:LOCALISATION_MODE.

TYPE DETAILS:
        semantic_slam:
            Use a semantic SLAM algorithm to build an object-based semantic
            map. An object-based semantic map specifies a set of objects, where
            each object is described by:
            - a suggested label (or distribution over possible labels) 
            - a global axis-aligned 3D bounding box (cuboid) describing the
            location of the object in 3D space.

        scd:
            Apply a semantic SLAM algorithm to perform scene change detection
            (SCD) between two scenes of the same environment. The two scenes
            will have a number of objects either added or removed with respect
            to each other. 

            Successful SCD produces an object-based semantic map as described
            above, with one key addition to each object description:
            - a suggested state change (either added, removed, or unchanged) or
            probability distribution over possible state changes.

CONTROL_MODE DETAILS:
        passive:
            Control of the robot is passive; 'move_next' is the only actuation
            modality provided to the user. The 'move_next' action automatically
            moves the robot from one target pose to the next.

            All further action of the robot will be disabled once the robot has
            traversed all possiible poses.

        active:
            Control of the robot is active'; the user can command the robot to
            either rotate on the spot with 'move_angle', or move forwards /
            backwards with 'move_distance'. Positive angles are anti-clockwise,
            & positive distances denote move forwards. Negative values perform
            the inverse for both actuation modalities.

            All further actuation of the robot will be disabled if a collision
            is detected with the environment. The task must be started again if
            this occurs.

LOCALISATION_MODE DETAILS:
        ground_truth:
            All localisation data is perfect, representing the exact position &
            orientation of the robot in the environment. Poses in robot
            observations can be considered correct without a need for
            localisation.

        dead_reckoning:
            Error in the robot's odometry measurements are not corrected. Poses
            in robot observations will accumulate this error over time, & must
            be corrected with a localisation process to enable the construction
            of accurate maps.
  "
}

function opt_select_env() {
  # Only update the SELECTED_ENV variable if it is in the list of envs
  for e in $(_env_list); do
    e=$(echo "$e" | tr -d '[:space:]')
    # TODO the number range for 2nd variation should probably not be hardcoded...
    if [[ "$1" =~ "$e"(:[1-5])?$ ]]; then 
      SELECTED_ENV="$1"
      return 0
    fi
  done
  echo "Environment '$1' is not a supported environment. Please check --list-envs."
  return 1
}

function opt_select_robot() {
  # Only update the SELECTED_ROBOT variable if it is in the list of robots
  SELECTED_ROBOT="sim"
}

function opt_select_task() {
  # Only update the SELECTED_TASK variable if it is in the list of tasks
  for t in ${_task_list[@]}; do
    if [ "$t" == "$1" ]; then
      SELECTED_TASK="$t"
      return 0
    fi
  done
  echo "Task '$1' is not a supported task specification. Please check --list-tasks."
  return 1
}


################################################################################
#################### Parse & handle command line arguments #####################
################################################################################

# Safely parse options input
parse_out=$(getopt -o he:t:r:fuv \
  --long help,env:,force-updateless,list-envs,list-robots,list-tasks,robot:,task:,updates-check,version \
  -n "$(basename "$abs_path")" -- "$@")
if [ $? != 0 ]; then exit 1; fi
eval set -- "$parse_out"
updates_exit=
updates_skip=
while true; do
  case "$1" in
    -h|--help)
      echo "$usage_text" ; exit 0 ;;
    -e|--env)
      _env_data_get ; opt_select_env "$2"; shift 2 ;;
    -f|--force-updateless)
      updates_skip=1 ; shift ;;
    --list-envs)
      _env_data_get ; opt_list_envs ; exit 0 ;;
    --list_robots)
      opt_list_robots ; exit 0 ;;
    --list-tasks)
      opt_list_tasks ; exit 0 ;;
    -r|--robot)
      opt_select_robot "$2"; shift 2 ;;
    -t|--task)
      opt_select_task "$2"; shift 2 ;;
    -u|--updates-check)
      updates_exit=1 ; shift ;;
    -v|--version)
      print_version_info; exit ;;
    --)
      shift ; break ;;
    *)
      echo "$(basename "$abs_path"): option '$1' is unknown"; shift ; exit 1 ;;
  esac
done

# Bail if we are running & they didn't give us both an environment & task
if [ -z "$updates_exit" ] && [ -z "$SELECTED_ENV" ]; then 
  printf "${colour_red}%s${colour_nc}\n" \
    "ERROR: No valid environment selected (selected_env = "$SELECTED_ENV")"
  exit 1
fi
if [ -z "$updates_exit" ] && [ -z "$SELECTED_TASK" ]; then 
  printf "${colour_red}%s${colour_nc}\n" \
    "ERROR: No valid task selected (selected_task = "$SELECTED_TASK")"
  exit 1
fi

# Ensure task & environment combo is valid
if [[ "$SELECTED_TASK" =~ .*"semantic_slam".* ]] && \
    [[ "$SELECTED_ENV" =~ ^[^:]+:[1-5]:[1-5]$ ]]; then
  printf "${colour_red}%s${colour_nc}\n" \
    "ERROR: Can't run Semantic SLAM with two environment variations!"
  exit 1
elif [[ "$SELECTED_TASK" =~ .*"scd".* ]] && \
    [[ "$SELECTED_ENV" =~ ^[^:]+:[1-5]$ ]]; then
  printf "${colour_red}%s%s${colour_nc}\n" \
    "ERROR: Can't run Scene Change Detection without "\
    "two environment variations!"
  exit 1
fi

################################################################################
##################### Run the simulator & BenchBot backend #####################
################################################################################

# Check for & handles updates to the BenchBot software stack
header_block "CHECKING FOR BENCHBOT SOFTWARE STACK UPDATES" ${colour_blue}

if [ ! -z "$updates_skip" ]; then 
  echo -e "${colour_yellow}Skipping ...${colour_nc}"
elif ! update_check "$(git branch -a --contains HEAD | grep -v HEAD | grep '.*remotes/.*' | head -n 1 | sed 's/.*\/\(.*\)/\1/')"; then 
  exit 1; 
fi
if [ ! -z "$updates_exit" ]; then exit 0; fi

# Run the BenchBot software stack (kill whenever they exit)
trap exit_gracefully SIGINT SIGQUIT SIGKILL SIGTERM
header_block "STARTING THE BENCHBOT SOFTWARE STACK" ${colour_blue}

# Cache environment data (digging into a docker to view files is expensive...
# lets only do that to our users once)
_env_data_get

# Pull out all useful data from the selected settings
selected_poses=($(_env_poses "$SELECTED_ENV"))
selected_map_paths=($(_env_map_paths "$SELECTED_ENV"))
selected_env_files=($(_env_files "$SELECTED_ENV"))
if [ ${#selected_poses[@]} -ne ${#selected_map_paths[@]} ] || \
    [ ${#selected_map_paths[@]} -ne ${#selected_env_files[@]} ]; then
  printf "${colour_red}$_map_details_err${colour_nc}\n" \
    "${#selected_map_paths[@]}" "${#selected_poses[@]}" \
    "${#selected_env_files[@]}"
  exit 1
fi

selected_actions=$(echo "$SELECTED_TASK" | sed 's/.*:\(.*\):.*/\1/')
selected_observations=$(echo "$SELECTED_TASK" | sed 's/.*:.*:\(.*\)/\1/')

# Print some configuration information
echo -n -e "${colour_blue}Running the BenchBot system with the following settings:${colour_nc}

    Selected environment: $SELECTED_ENV
    Selected task:        $SELECTED_TASK
    Actions set:          $selected_actions
    Observations set:     $selected_observations
    Maps:                 "
for i in "${!selected_map_paths[@]}"; do
  if [ $i -ne 0 ]; then
    printf "%*s" 26
  fi
  printf "%s\n" "${selected_map_paths[$i]}"
  printf "%*s" 26
  printf "(starting @ %s)\n" "${selected_poses[$i]}"
done
echo ""

# Create the network for BenchBot software stack
echo -e "${colour_blue}Creating shared network '$DOCKER_NETWORK':${colour_nc}"
docker network create "$DOCKER_NETWORK" --subnet="$URL_DOCKER_SUBNET" \
  --ip-range="$URL_DOCKER_SUBNET" --gateway="$URL_DOCKER_GATEWAY"

# Declare reusable parts to ensure our containers run with consistent settings
xhost +local:root > /dev/null
ros_master_host="benchbot_roscore"
docker_run="docker run -t --gpus all -v /tmp/.X11-unix:/tmp/.X11-unix \
            -e DISPLAY \
            -e ROS_MASTER_URI=http://$ros_master_host:11311 -e ROS_HOSTNAME=\$name \
            --network $DOCKER_NETWORK --name=\$name --hostname=\$name"
cmd_prefix='source $ROS_WS_PATH/devel/setup.bash && '

# Start containers for ROS, isaac_simulator, benchbot_simulator, & benchbot_supervisor
echo -e "\n${colour_blue}Starting container for BenchBot ROS:${colour_nc}"
name="$ros_master_host"
${docker_run//'$name'/$name} --ip "$URL_ROS" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'roscore'

echo -e "\n${colour_blue}Starting container for BenchBot Simulator:${colour_nc}"
name="benchbot_simulator"
${docker_run//'$name'/$name} --ip "$URL_SIMULATOR" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'$BENCHBOT_SIMULATOR_PATH/scripts/simulator_controller \
  --file-collisions /tmp/benchbot_collision --file-dirty-state /tmp/benchbot_dirty \
  --path-envs '$(dirname $(dirname $(_env_path $SELECTED_ENV)))' \
  --path-isaac $ISAAC_SDK_PATH --path-simulator $BENCHBOT_SIMULATOR_PATH \
  --port '"$PORT_SIMULATOR"' \
  '"$FILENAME_ENV_METADATA"' '"$( IFS=$':'; echo "${selected_map_paths[*]}")"' \
  '"$( IFS=$':'; echo "${selected_poses[*]}")"
while [ $(docker ps -q -f "name=$name" | wc -l) -eq 0 ]; do sleep 1; done

echo -e "\n${colour_blue}Starting container for BenchBot Supervisor:${colour_nc}"
name="benchbot_supervisor"
${docker_run//'$name'/$name} --ip "$URL_SUPERVISOR" -d $DOCKER_TAG_BACKEND /bin/bash -c \
  "$cmd_prefix"'rosrun benchbot_supervisor benchbot_supervisor \
  _task_name:="'"$SELECTED_TASK"'" _robot_file:="carter.yaml" \
  _observations_file:="'"$selected_observations"'.yaml" \
  _actions_file:="'"$selected_actions"'_control.yaml"\
  _environment_files:='"$( IFS=$':'; echo "${selected_env_files[*]}")"' \
  _simulator_address:='"${HOSTNAME_SIMULATOR}"':'"${PORT_SIMULATOR}"

echo -e "\n${colour_blue}Starting container for BenchBot Debugging:${colour_nc}"
name="benchbot_debug"
# ${docker_run//'$name'/$name} --user root --privileged -v /dev:/dev -i $DOCKER_TAG_BACKEND
${docker_run//'$name'/$name} -it -d $DOCKER_TAG_BACKEND
xhost -local:root > /dev/null

# Print the output of the Supervisor, watching for failures
header_block "BENCHBOT IS RUNNING (Ctrl^C to exit) ..." ${colour_green}

docker logs benchbot_supervisor
docker attach benchbot_supervisor --no-stdin &

while [ ! -z $(docker ps -q -f 'name=benchbot_supervisor') ] && \
    [ ! -z $(docker ps -q -f 'name=benchbot_simulator') ]; do
  sleep 1
done

if [ -z $(docker ps -q -f 'name=benchbot_simulator') ]; then
  header_block "BENCHBOT SIMULATOR ERROR" ${colour_red}
  echo -e "\n${colour_red}$_simulator_err${colour_nc}\n"
  docker logs benchbot_simulator
fi
exit_gracefully 1
