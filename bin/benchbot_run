#!/usr/bin/env bash

################################################################################
################### Load Helpers & Global BenchBot Settings ####################
################################################################################

abs_path=$(readlink -f $0)
pushd $(dirname $abs_path) > /dev/null
source .helpers

################################################################################
########################### Script Specific Settings ###########################
################################################################################

# empty

################################################################################
######################## Helper functions for commands #########################
################################################################################

usage_text="$(basename "$abs_path") -- Run script for the BenchBot backend & simulator

USAGE:

    Get info about the program / available options:
        $(basename "$abs_path") [-h|--help|--list-tasks|--list-envs]

    Run a simulator with a specifc task setup:
        $(basename "$abs_path") --env ENV_NAME --task TASK_NAME
        $(basename "$abs_path") -e ENV_NAME -t TASK_NAME

OPTION DETAILS:

    -h,--help             
            Show this help menu.

    --list-envs
            Search for & list all installed environments. The listed
            environment names are in the format needed for the --env option.

    --list-tasks   
            Lists all supported task combinations. The listed tasks are printed
            in the format needed for the --task option.

    -e, --env             
            Select an environment to launch in the simulator (this must be
            called with the --task option). Environments are identified via
            \"ENVIRONMENT_NAME:VARIATION_NUMBER\" where ENVIRONMENT_NAME is the
            name of simulated environment & VARIATION_NUMBER environment
            variation to use. For example, the third variation of the office
            environment would be: 

                    office:3

            Two variation numbers must be specified for scene change detection
            using the format \"ENVIRONMENT_NAME:VARIATION_ONE:VARIATION_TWO\".
            For example detecting the changes in the third variation of the
            office with respect to the first variation would be:

                    office:1:3

            (Use --list-envs to see a list of available environments)

    -t, --task             
            Configure BenchBot for a specific task style (this must be called
            with the --env option). A task is specified through the format
            \"TYPE:CONTROL_MODE:LOCALISATION_MODE\" where TYPE is the type of
            task, CONTROL_MODE is the control options available on the robot, &
            LOCALISATION_MODE is the accuracy of localisation feedback
            received. For example, a robot with passive control & ground truth
            localisation completing semantic SLAM would be:

                    semantic_slam:passive:ground_truth

            (Use --list-tasks to see a list of supported task options)

    -f, --force-updateless
            BenchBot will exit if it detects updates to the software stack. Set
            this flag to continue using outdated software temporarily. Note that
            limited support is available for outdated software stacks, and the
            challenge will run on the latest software stack. You should only use
            this flag when it is inconvenient to update immediately.

    -u,--update-check
            Check for available updates to the BenchBot software stack and exit
            immediately.

FURTHER DETAILS:
    
    Please contact the authors of BenchBot for support or to report bugs:
        b.talbot@qut.edu.au
    "

SELECTED_ENV=
SELECTED_TASK=

_task_list=("semantic_slam:passive:ground_truth"
  "semantic_slam:active:ground_truth"
  "semantic_slam:active:dead_reckoning"
  "scd:passive:ground_truth"
  "scd:active:ground_truth"
  "scd:active:dead_reckoning"
)

_env_data_full_cached=

function _env_file() {
  echo "$(_env_data $1)" | head -1 | tr -d '[:space:]'
}

function _env_data() {
  while read -r line; do
    if [ -z "$found" ] && echo "$line" | grep -q '^/.*'"${1/:/_}"'\.yaml'; then
      found=true
      echo "$line"
    elif [ ! -z "$found" ] && echo "$line" | grep -q '^/.*\.yaml'; then
      return 0
    elif [ ! -z "$found" ]; then
      echo "$line"
    fi
  done <<< "$(_env_data_full)"
  return 1
}

function _env_data_full() {
  # This is a little gross... sorry.
  if [ -z "$_env_data_full_cached" ]; then
    _env_data_full_cached=$(docker run --rm -t $DOCKER_TAG_SIMULATOR /bin/bash \
      -c 'find $BENCHBOT_ENVS_PATH/'$FILENAME_ENV_METADATA' -name "*.yaml"\
      | while read env; do echo "$(realpath $env)"; cat $env; echo ""; done')
  fi
  echo "$_env_data_full_cached"
}

function _env_list() {
  echo "$(_env_data_full)" | grep "environment_name:" | \
    sed 's/.*: "\([^_]*\)_\([^"]*\).*/\1:\2/' | sort
}

function _env_map_path() {
  # Nested while... not quite ideal
  echo "$(_env_data $1)" | sed -n 's/.*map_path: \(.*\)/\1/p' | tr -d '[:space:]'
}

function _env_pose() {
  # Nested while... not quite ideal
  echo "$(_env_data $1)" | sed -n 's/.*start_pose_local: \(.*\)/\1/p' | tr -d '[:space:]'
}

function opt_list_envs() {
  # TODO check if installed (docker image exists); provide a message if not
  # telling them how to fix the issue

  # Print the list with details
  echo "The following environments are installed in your BenchBot Docker image:
  "
  for e in $(_env_list); do
    echo "        $e"
  done
  echo "
The string is of the format ENV_NAME:VARIATION_NUMBER. Note when running the
semantic change detection tasks you will have to specifiy a second variation
using the format ENV_NAME:VARIATION_NUMBER_ONE:VARIATION_NUMBER_TWO.
  "
}

function opt_list_tasks() {
  # TODO this is hard coded for now... maybe should be done differently...
  echo "The following tasks are supported by BenchBot: 
  "
  for t in "${_task_list[@]}"; do
    echo "        $t"
  done
  echo "
The string is of the format TYPE:CONTROL_MODE:LOCALISATION_MODE.

TYPE DETAILS:
        semantic_slam:
            SLAM with localisation and mapping performed with respect to
            objects, not sensor data.

        scd:
            Semantic Change Detection
            Move through an environment multiple (two?) times and report changes
            in the environment in terms of objects added or removed.

CONTROL_MODE DETAILS:
        passive:
            Control of the robot is limited to only being able to say
            'move_next'. Robot moves from one target position to the next
            automatically after being given this command.

        active:
            Control of the robot is not limited to moving along nodes on a path.
            You can tell the robot to 'move_distance' or 'move_angle', and it
            will do its best to move the specified amount. The robot will report
            collisions and end movement early.

LOCALISATION_MODE DETAILS:
        ground_truth:
            All sensor data is perfect and represents the exact position and
            orientation of the robot. All images are noiseless. Depth images
            represent the exact depth from the camera to the objecs they see.

        dead_reckoning:
            Sensor data is not perfect. In particular, due to noise, the robot
            position and orientation will drift off course the longer the robot
            runs. Images have noise. Depth images have noise and will have
            holes where no depth data can be retrieved.
  "
}

function opt_select_env() {
  # Only update the SELECTED_ENV variable if it is in the list of envs
  for e in $(_env_list); do
    e=$(echo "$e" | tr -d '[:space:]')
    # TODO the number range for 2nd variation should probably not be hardcoded...
    if [[ "$1" =~ "$e"(:[1-5])?$ ]]; then 
      SELECTED_ENV="$1"
      return 0
    fi
  done
  echo "Environment '$1' is not a supported environment. Please check --list-envs."
  return 1
}

function opt_select_task() {
  # Only update the SELECTED_TASK variable if it is in the list of tasks
  for t in ${_task_list[@]}; do
    if [ "$t" == "$1" ]; then
      SELECTED_TASK="$t"
      return 0
    fi
  done
  echo "Task '$1' is not a supported task specification. Please check --list-tasks."
  return 1
}


################################################################################
#################### Parse & handle command line arguments #####################
################################################################################

# Safely parse options input
parse_out=$(getopt -o he:t:fu --long help,env:,task:,list-envs,list-tasks,force-updateless,updates-check \
  -n "$(basename "$abs_path")" -- "$@")
if [ $? != 0 ]; then exit 1; fi
eval set -- "$parse_out"
updates_exit=
updates_skip=
while true; do
  case "$1" in
    -h|--help)
      echo "$usage_text" ; exit 0 ;;
    --list-envs)
      opt_list_envs ; exit 0 ;;
    --list-tasks)
      opt_list_tasks ; exit 0 ;;
    -e|--env)
      opt_select_env "$2"; shift 2 ;;
    -t|--task)
      opt_select_task "$2"; shift 2 ;;
    -f|--force-updateless)
      updates_skip=1 ; shift ;;
    -u|--updates-check)
      updates_exit=1 ; shift ;;
    --)
      shift ; break ;;
    *)
      echo "$(basename "$abs_path"): option '$1' is unknown"; shift ; exit 1 ;;
  esac
done

# Bail if we are running & they didn't give us both an environment & task
if [ -z "$updates_exit" ] && [ -z "$SELECTED_ENV" ]; then 
  echo "ERROR: No valid environment selected (selected_env = "$SELECTED_ENV")"
  exit 1
fi
if [ -z "$updates_exit" ] && [ -z "$SELECTED_TASK" ]; then 
  echo "ERROR: No valid task selected (selected_task = "$SELECTED_TASK")"
  exit 1
fi

# Ensure task & environment combo is valid
if [[ "$SELECTED_TASK" =~ .*"semantic_slam".* ]] && \
    [[ "$SELECTED_ENV" =~ ^[^:]+:[1-5]:[1-5]$ ]]; then
  echo "ERROR: Can't run Semantic SLAM with two environment variations!"
  exit 1
elif [[ "$SELECTED_TASK" =~ .*"scd".* ]] && \
    [[ "$SELECTED_ENV" =~ ^[^:]+:[1-5]$ ]]; then
  s="ERROR: Can't run Scene Change Detection without "
  s+="two environment variations!"
  echo "$s"
  exit 1
fi

################################################################################
##################### Run the simulator & BenchBot backend #####################
################################################################################

# Check for & handles updates to the BenchBot software stack
header_block "CHECKING FOR BENCHBOT SOFTWARE STACK UPDATES" ${colour_blue}

if [ ! -z "$updates_skip" ]; then 
  echo -e "${colour_yellow}Skipping ...${colour_nc}"
elif ! update_check "$(git name-rev HEAD | cut -d ' ' -f 2 | sed 's/.*\///')"; then 
  exit 1; 
fi
if [ ! -z "$updates_exit" ]; then exit 0; fi

# Run the BenchBot software stack (kill whenever they exit)
trap kill_benchbot EXIT
header_block "STARTING THE BENCHBOT SOFTWARE STACK" ${colour_blue}

# Pull out all useful data from the selected settings
selected_pose=$(_env_pose "$SELECTED_ENV")
selected_map_path=$(_env_map_path "$SELECTED_ENV")
selected_actions=$(echo "$SELECTED_TASK" | sed 's/.*:\(.*\):.*/\1/')
selected_observations=$(echo "$SELECTED_TASK" | sed 's/.*:.*:\(.*\)/\1/')
selected_env_file=$(_env_file "$SELECTED_ENV")

# Print some configuration information
echo "Running the BenchBot system with the following settings:

    Selected environment: $SELECTED_ENV
    Selected task:        $SELECTED_TASK
    Map path:             $selected_map_path
    Map start pose:       $selected_pose 
    Actions set:          $selected_actions
    Observations set:     $selected_observations
"

# Create the network for BenchBot software stack
docker network create "$DOCKER_NETWORK" --subnet="$URL_DOCKER_SUBNET" \
  --ip-range="$URL_DOCKER_SUBNET" --gateway="$URL_DOCKER_GATEWAY"
echo -e "Created $DOCKER_NETWORK.\n"

# Declare reusable parts to ensure our containers run with consistent settings
xhost +local:root
ros_master_host="benchbot_roscore"
docker_run="docker run -t --gpus all -v /tmp/.X11-unix:/tmp/.X11-unix \
            -e DISPLAY \
            -e ROS_MASTER_URI=http://$ros_master_host:11311 -e ROS_HOSTNAME=\$name \
            --network $DOCKER_NETWORK --name=\$name --hostname=\$name"
cmd_prefix='source $ROS_WS_PATH/devel/setup.bash && '

# Start containers for ROS, isaac_simulator, benchbot_simulator, & benchbot_supervisor
name="$ros_master_host"
${docker_run//'$name'/$name} --ip "$URL_ROS" -d $DOCKER_TAG_SIMULATOR /bin/bash -c \
  "$cmd_prefix"'roscore'

name="benchbot_simulator"
${docker_run//'$name'/$name} --ip "$URL_SIMULATOR" -d $DOCKER_TAG_SIMULATOR /bin/bash -c \
  "$cmd_prefix"'$BENCHBOT_SIMULATOR_PATH/scripts/simulator_controller \
  --file-collisions /tmp/benchbot_collision --file-dirty-state /tmp/benchbot_dirty \
  --path-envs $BENCHBOT_ENVS_PATH --path-isaac $ISAAC_SDK_PATH \
  --path-simulator $BENCHBOT_SIMULATOR_PATH --port '"$PORT_SIMULATOR"' \
  '"$selected_map_path"' '"$FILENAME_ENV_METADATA"' '"$selected_pose"

name="benchbot_supervisor"
${docker_run//'$name'/$name} --ip "$URL_SUPERVISOR" -d $DOCKER_TAG_SIMULATOR /bin/bash -c \
  "$cmd_prefix"'rosrun benchbot_supervisor benchbot_supervisor \
  _task_name:="'"$SELECTED_TASK"'" _robot_file:="carter.yaml" \
  _observations_file:="'"$selected_observations"'.yaml" \
  _actions_file:="'"$selected_actions"'_control.yaml"\
  _environment_file:='"$selected_env_file"' \
  _simulator_address:='"${HOSTNAME_SIMULATOR}"':'"${PORT_SIMULATOR}"

name="benchbot_debug"
# ${docker_run//'$name'/$name} --user root --privileged -v /dev:/dev -i $DOCKER_TAG_SIMULATOR
${docker_run//'$name'/$name} -it -d $DOCKER_TAG_SIMULATOR
xhost -local:root

header_block "BENCHBOT IS RUNNING (Ctrl^C to exit) ..." ${colour_green}

docker attach benchbot_supervisor
